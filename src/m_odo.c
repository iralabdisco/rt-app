#include "m_odo.h"

#ifdef DBG_TEST_TRACE
/**
 * @brief Print a trace of what the worker is doing. \b DANGER! It uses
 * #printf() which is not RT-safe.
 *
 * @param pb A pointer to the #posebuffer to debug
 * @param itercount A pointer to a variable holding a count of total
 * iterations
 * @param errcount A pointer to a variable holding a count of the times the
 * clock mislabeled a pose
 */
void MOdometry_PrintTestTrace(posebuf_t* pb, int* itercount, int* errcount) {
    printf("\n");
    pose_t* cur;
    double elapsed;
    if (pb->old == &pb->a) {
        printf("Current pose: B\n");
        cur = &pb->b;
    } else {
        printf("Current pose: A\n");
        cur = &pb->a;
    }
    printf(
        "Timestamp:\t\t%llu\n"
        "Values:\tX:\t\t%f\n"
        "\tY:\t\t%f\n"
        "\tAlpha:\t\t%f\n",
        cur->ts, cur->x, cur->y, cur->th);
    if (pb->old->ts != 0) {
        elapsed = cur->ts - pb->old->ts;
        printf("Elapsed (ns): %.0f", elapsed);
        if (elapsed < 0) {
            printf("\tCLOCK MISS!");
            (*errcount)++;
        }
    }
    if (cur->next != pb->old)
        printf("\n-- ERROR --\n Pointer swap inconsistent.\n");
    (*itercount)++;
    printf("\nIter:\tTotal: %d\n\tErrors: %d\n\tRate: %g%%\n", *itercount,
           *errcount, (*errcount) / (*itercount) * 100.0);
    if (*itercount == 10) {
        printf(
            "\n-- DEBUG --\nTest trace termination after 10 iterations.\n"
            "Exiting.\n");
        exit(0);
    }
}
#endif

void MOdo_PrintStatsCold(const odoStats_t* stats) {
    printf("Statistics (cold):\nIterations:\t%d\nClock Errors:\t%d\n",
           stats->totalIterations, stats->clockMisses);
    return;
}

/**
 * @brief Initialize a posebuffer, setting the poses as 0,0,0,0 and the
 * discardable pose to a. Note that the poses make an implicit ringbuffer.
 *
 * @param pb A pointer to the posebuffer to be initialized
 */
void MOdo_initPoseBuffer(posebuf_t* pb) {
    pb->old = &pb->a;
    pb->a = (pose_t){.ts = 0, .x = 0, .y = 0, .th = 0, .next = &pb->b};
    pb->b = (pose_t){.ts = 0, .x = 0, .y = 0, .th = 0, .next = &pb->a};
    // memcpy(&pb->b, &pb->a, sizeof(pose_t));
}

/**
 * @brief Handler to be called when a SIGXCPU signal is generated by the
 * scheduler when missing a deadline and SCHED_FLAG_DL_OVERRUN is on
 *
 * @param sig The number of the received signal.
 */
void deadline_miss_handler(int sig) {
    printf("MOdo_EntryPoint: Deadline miss detected (0x%4x)\n", sig);
    // TODO what to do when a deadline is missed
    //(void)signal(SIGXCPU, SIG_DFL);
}

/**
 * @brief The Odometry worker thread. Here's where all the magic happens.
 *
 * @param args A pointer to a memory area representing arguments. By default,
 * NULL is passed. This could be useful if we have a thread pool, see
 * https://computing.llnl.gov/tutorials/pthreads/
 * @return void* Nothing is returned.
 */
<<<<<<< HEAD:src/m_odo.c
void* MOdo_EntryPoint(void* args) {
    assert(args ==
           NULL);  // Ensure we are not passing arguments (I admit doing
                   // this only to remove a compile-time warning)
=======
void* O_Worker(void* args) {
>>>>>>> parent of 1a05121... New build model, fixed minor issue in posebuf's brief, initial otto adapter skel:src/odo.c
    struct sched_attr attr = {
        .size = sizeof(attr),
        .sched_flags = 0 | SCHED_FLAG_DL_OVERRUN,
        .sched_policy = SCHED_DEADLINE,
        .sched_runtime = 10 * 1000 * 1000,  // 10ms
        .sched_period =
            20 * 1000 * 1000,  //* 1000,  // 2s // HACK cos'è cambiato?
        .sched_deadline = 11 * 1000 * 1000};       // 11ms
    (void)signal(SIGXCPU, deadline_miss_handler);  // Register signal handler
    if (sched_setattr(0, &attr, 0)) {
        perror("MOdo_EntryPoint: sched_setattr");
        exit(EXIT_FAILURE);
    }
    // BEGIN Worker variables
    arc_t sx = 0;  // TODO Encoder, implement protobuf adapter
    arc_t dx = 0;
    posebuf_t pb;
<<<<<<< HEAD:src/m_odo.c
    double b = 0.435; /* Federica Di Lauro, [06.02.21 15:08]
                       * [In reply to Federica Di Lauro]
                       * questo è quello di otto, non ricordo cosa venisse
                       *fuori per l'esercizio di matlab
                       **/
    odoStats_t stats = {.targetIterations = MAX_ITERS,
                        .totalIterations = 0,
                        .clockMisses = 0};
=======
    double b = 0;  // TODO Define distance between wheel contact points
    o_stats_t stats = {
        .targetIterations = MAX_ITERS, .totalIterations = 0, .clockMisses = 0};
>>>>>>> parent of 1a05121... New build model, fixed minor issue in posebuf's brief, initial otto adapter skel:src/odo.c
    struct timespec gts;
    // END Worker variables
    MOdo_initPoseBuffer(&pb);
    HTime_InitBase();  // TODO Move Timebase init to main?
    for (;;) {
        // BEGIN Worker code
        // TODO Get values from sensors
        pose_t* cur =
            pb.old;  // Select the pose to work on in the current iteration
        pb.old = pb.old->next;  // And mark the other one as disposable
        arc_t delta = sx - dx;
<<<<<<< HEAD:src/m_odo.c
        cur->ts = HTime_GetNsDelta(&gts);
        printf("%llu,", cur->ts);
=======
        if (clock_gettime(CLOCK_MONOTONIC, &gts) == -1) { // ts update
            perror("O_Worker: clock_gettime");
            exit(EXIT_FAILURE);
        }
        cur->ts = (gts.tv_sec * 1e6 + gts.tv_nsec) - bts;
>>>>>>> parent of 1a05121... New build model, fixed minor issue in posebuf's brief, initial otto adapter skel:src/odo.c
        // TODO proofread & static test
        if (delta == 0) {  // We are going forward
            cur->x = pb.old->x + cos(pb.old->th) * delta;
            cur->y = pb.old->y + sin(pb.old->th) * delta;
            cur->th = pb.old->th;
        } else {  // We are going left or right
            cur->x =
                pb.old->x -
                (b / 2 + dx * b / delta) * (sin(pb.old->th - delta) / b) -
                sin(pb.old->th);
            cur->y =
                pb.old->y +
                (b / 2 + dx * b / delta) * (cos(pb.old->th - delta) / b) -
                cos(pb.old->th);
            cur->th = pb.old->th - delta / b;
        }
        stats.totalIterations++;
        if ((pb.old->ts != 0) && (cur->ts - pb.old->ts < 0))
            stats.clockMisses++;
#ifdef CUT_SHORT
        if (stats.totalIterations == stats.targetIterations) break;
#endif
        // END Worker code
        sched_yield();
    };
    MOdo_PrintStatsCold(&stats);
    pthread_exit(EXIT_SUCCESS);
    return (NULL);
}
