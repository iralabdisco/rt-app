#include "m_odo.h"

/**
 * @brief Initialize a posebuffer, setting the poses as 0,0,0,0 and the
 * discardable pose to a. Note that the poses are arranged into an implicit
 * ringbuffer.
 *
 * @param pb A pointer to the posebuffer to be initialized
 */
void MOdo_InitPoseBuffer(posebuf_t* pb) {
    pb->old = &pb->a;
    pb->a = (pose_t){.ts = 0, .x = 0, .y = 0, .th = 0, .next = &pb->b};
    pb->b = (pose_t){.ts = 0, .x = 0, .y = 0, .th = 0, .next = &pb->a};
}

/**
 * @brief Handler to be called when a SIGXCPU signal is generated by the
 * scheduler when missing a deadline and SCHED_FLAG_DL_OVERRUN is on
 *
 * @param sig The number of the received signal.
 */
void MOdo_DLMissHandler(int sig) {
    assert(sig != 0);  // Ensure signature is not null (I admit
    // doing this only to remove a compile-time warning)
    // https://bytefreaks.net/programming-2/cc-comparing-the-performance-of-syslog-vs-printf
    syslog(LOG_WARNING, "%s", "MOdo_EntryPoint: Deadline miss detected");
    // TODO recovery, what to do when a deadline is missed? At the moment,
    // we're launching the default handler
    //(void)signal(SIGXCPU, SIG_DFL);
}

/**
 * @brief The Odometry worker thread. Here's where all the magic happens.
 *
 * @param args A pointer to a memory area representing arguments. By default,
 * NULL is passed. This could be useful if we have a thread pool, see
 * https://computing.llnl.gov/tutorials/pthreads/
 * @return void* Nothing is returned.
 */
void* MOdo_EntryPoint(void* args) {
    assert(args ==
           NULL);  // Ensure we are not passing arguments (I admit doing
                   // this only to remove a compile-time warning)
    struct sched_attr attr = {.size = sizeof(attr),
                              .sched_flags = 0 | SCHED_FLAG_DL_OVERRUN,
                              .sched_policy = SCHED_DEADLINE,
                              .sched_runtime = 10 * 1000 * 1000,    // 10ms
                              .sched_period = 20 * 1000 * 1000,     // 20ms
                              .sched_deadline = 11 * 1000 * 1000};  // 11ms
    (void)signal(SIGXCPU, MOdo_DLMissHandler);  // Register signal handler
    if (sched_setattr(0, &attr, 0)) {
#ifdef CONFIG_PRINT_ERRORS
        perror("MOdo_EntryPoint: sched_setattr");
#endif  // CONFIG_PRINT_ERRORS
        exit(EXIT_FAILURE);
    }
    // BEGIN Worker variables
    arc_t sx = 0;
    arc_t dx = 0;
    posebuf_t pb;
    double b = USE_BASELINE;
#ifdef CONFIG_CUT_SHORT
    odoStats_t stats = {.targetIterations = CONFIG_MAX_ITERS,
                        .totalIterations = 0,
                        .clockMisses = 0};
#endif  // CONFIG_CUT_SHORT
    struct timespec gts;
    int ottoCharDeviceFd;
    StatusMessage msg = StatusMessage_init_zero;
    // END Worker variables
    ottoCharDeviceFd = AOtto_Init();
    MOdo_InitPoseBuffer(&pb);
    HTime_InitBase();  // XXX see h_time.h
    for (;;) {
        // BEGIN Worker code
        AOtto_ReadDeserialize(ottoCharDeviceFd, &msg);
#ifdef CONFIG_PRINT_MSG_VALUES
        printf("A:%f,L:%f,T:%d,S:%d\n", msg.angular_velocity,
               msg.linear_velocity, msg.delta_millis, msg.status);
#endif  // CONFIG_PRINT_MSG_VALUES
        pose_t* cur =
            pb.old;  // Select the pose to work on in the current iteration
        pb.old = pb.old->next;  // And mark the other one as disposable
        arc_t delta = sx - dx;
        cur->ts = HTime_GetNsDelta(&gts);
        // TODO proofread & static test
        if (delta == 0) {  // We are going forward
            cur->x = pb.old->x + cos(pb.old->th) * delta;
            cur->y = pb.old->y + sin(pb.old->th) * delta;
            cur->th = pb.old->th;
        } else {  // We are going left or right
            cur->x =
                pb.old->x -
                (b / 2 + dx * b / delta) * (sin(pb.old->th - delta) / b) -
                sin(pb.old->th);
            cur->y =
                pb.old->y +
                (b / 2 + dx * b / delta) * (cos(pb.old->th - delta) / b) -
                cos(pb.old->th);
            cur->th = pb.old->th - delta / b;
        }
        stats.totalIterations++;
#ifdef CONFIG_CUT_SHORT
        if (stats.totalIterations == stats.targetIterations) break;
#endif
        // END Worker code
        sched_yield();
    };
    pthread_exit(EXIT_SUCCESS);
    return (NULL);
}
