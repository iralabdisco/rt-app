#include "odo.h"

#ifdef DBG_TEST_TRACE
/**
 * @brief Print a trace of what the worker is doing. \b DANGER! It uses
 * #printf() which is not RT-safe.
 *
 * @param pb A pointer to the #posebuffer to debug
 * @param iterCount A pointer to a variable holding a count of total iterations
 * @param errCount A pointer to a variable holding a count of the times the
 * clock mislabeled a pose
 */
void O_PrintTrace(posebuf_t* pb, int* iterCount, int* errCount) {
    printf("\n");
    pose_t* cur;
    double elapsed;
    if (pb->old == &pb->a) {
        printf("Current pose: B\n");
        cur = &pb->b;
    } else {
        printf("Current pose: A\n");
        cur = &pb->a;
    }
    printf(
        "Timestamp:\t\t%g\n"
        "Values:\tX:\t\t%f\n"
        "\tY:\t\t%f\n"
        "\tAlpha:\t\t%f\n",
        cur->ts, cur->x, cur->y, cur->th);
    if (pb->old->ts != 0) {
        elapsed = cur->ts - pb->old->ts;
        printf("Elapsed (ns): %.0f", elapsed);
        if (elapsed < 0) {
            printf("\tCLOCK MISS!");
            (*errCount)++;
        }
    }
    if (cur->next != pb->old)
        printf("\n-- ERROR --\n Pointer swap inconsistent.\n");
    (*iterCount)++;
    printf("\nIter:\tTotal: %d\n\tErrors: %d\n\tRate: %g%%\n", *iterCount,
           *errCount, (*errCount) / (*iterCount) * 100.0);
    if (*iterCount == 10) {
        printf(
            "\n-- DEBUG --\nTest trace termination after 10 iterations.\n"
            "Exiting.\n");
        exit(0);
    }
}
#endif

void O_PrintStats(o_stats_t* stats) {
    printf("Statistics (cold):\nIterations:\t%d\nClock Errors:\t%d\n",
           stats->totalIterations, stats->clockMisses);
    return;
}

/**
 * @brief Initialize a posebuffer, setting the poses as 0,0,0,0 and the
 * discardable pose to a. Note that the poses make an implicit ringbuffer.
 *
 * @param pb A pointer to the posebuffer to be initialized
 */
void O_InitPoseBuf(posebuf_t* pb) {
    pb->old = &pb->a;
    pb->a = (pose_t){.ts = 0, .x = 0, .y = 0, .th = 0, .next = &pb->b};
    pb->b = (pose_t){.ts = 0, .x = 0, .y = 0, .th = 0, .next = &pb->a};
    // memcpy(&pb->b, &pb->a, sizeof(pose_t));
}

/**
 * @brief Handler to be called when a SIGXCPU signal is generated by the
 * scheduler when missing a deadline and SCHED_FLAG_DL_OVERRUN is on
 *
 * @param sig The number of the received signal.
 */
void O_DLMissHandler(int sig) {
    printf("O_Worker: Deadline miss detected (0x%4x)\n", sig);
    // TODO what to do when a deadline is missed
    //(void)signal(SIGXCPU, SIG_DFL);
}

/**
 * @brief The Odometry worker thread. Here's where all the magic happens.
 *
 * @param args A pointer to a memory area representing arguments. By default,
 * NULL is passed. This could be useful if we have a thread pool, see
 * https://computing.llnl.gov/tutorials/pthreads/
 * @return void* Nothing is returned.
 */
void* O_Worker(void* args) {
    struct sched_attr attr = {
        .size = sizeof(attr),
        .sched_flags = 0 | SCHED_FLAG_DL_OVERRUN,
        .sched_policy = SCHED_DEADLINE,
        .sched_runtime = 10 * 1000 * 1000,    // 10ms
        .sched_period = 20 * 1000 * 1000,     //* 1000,  // 2s
        .sched_deadline = 11 * 1000 * 1000};  // 11ms
    (void)signal(SIGXCPU, O_DLMissHandler);   // Register signal handler
    if (sched_setattr(0, &attr, 0)) {
        perror("O_Worker: sched_setattr");
        exit(EXIT_FAILURE);
    }
    // BEGIN Worker variables
    arc_t sx = 0;  // TODO Encoder, implement protobuf adapter
    arc_t dx = 0;
    posebuf_t pb;
    double b = 0;  // TODO Define distance between wheel contact points
    o_stats_t stats = {
        .targetIterations = MAX_ITERS, .totalIterations = 0, .clockMisses = 0};
    struct timespec gts;
    // XXX <-- DA VAGLIARE MI FANNO IL CULO
    // Granularità vs. Risoluzione
    // Velocità della richiesta
    // https://elinux.org/High_Resolution_Timers dà una risposta sommaria, il
    // timer è basato sullo "jiffy", che è un'unità di misura di tempo interna
    // del kernel che varia in base all'architettura. Possiamo inoltre fare `cat
    // /proc/timer_list` per vedere una lista dei timer e delle loro capacità.
    if (clock_gettime(CLOCK_MONOTONIC, &gts) == -1) {
        perror("O_Worker: clock_gettime");
        exit(EXIT_FAILURE);
    }
    double bts = gts.tv_sec * 1e6 + gts.tv_nsec;
    // End Timing Stuff
    O_InitPoseBuf(&pb);
    // END Worker variables
    for (;;) {
        // BEGIN Worker code
        // TODO Get values from sensors
        pose_t* cur =
            pb.old;  // Select the pose to work on in the current iteration
        pb.old = pb.old->next;  // And mark the other one as disposable
        arc_t delta = sx - dx;
        if (clock_gettime(CLOCK_MONOTONIC, &gts) == -1) { // ts update
            perror("O_Worker: clock_gettime");
            exit(EXIT_FAILURE);
        }
        cur->ts = (gts.tv_sec * 1e6 + gts.tv_nsec) - bts;
        // TODO proofread & static test
        if (delta == 0) {  // We are going forward
            cur->x = pb.old->x + cos(pb.old->th) * delta;
            cur->y = pb.old->y + sin(pb.old->th) * delta;
            cur->th = pb.old->th;
        } else {  // We are going left or right
            cur->x = pb.old->x -
                     (b / 2 + dx * b / delta) * (sin(pb.old->th - delta) / b) -
                     sin(pb.old->th);
            cur->y = pb.old->y +
                     (b / 2 + dx * b / delta) * (cos(pb.old->th - delta) / b) -
                     cos(pb.old->th);
            cur->th = pb.old->th - delta / b;
        }
        stats.totalIterations++;
        if ((pb.old->ts != 0) && (cur->ts - pb.old->ts < 0))
            stats.clockMisses++;
#ifdef CUT_SHORT
        if (stats.totalIterations == stats.targetIterations) break;
#endif
        // END Worker code
        sched_yield();
    };
    O_PrintStats(&stats);
    pthread_exit(EXIT_SUCCESS);
    return (NULL);
}
